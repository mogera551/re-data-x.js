(()=>{"use strict";class e{target;thisArg;args;constructor(e,t,s){this.target=e,this.thisArg=t,this.args=s}async exec(e=this.target,t=this.thisArg,s=this.args){return await Reflect.apply(e,t,s)}}class t{queue=[];enqueue(e,t=this.queue){t.push(e)}async exec(e=this.queue){for(;;){const t=e.slice();if(0===t.length)break;e.splice(0);for(const e of t)await e.exec()}}}const s=class{static getPath(e,t){let s=0;return e.replaceAll("*",(()=>t[s++]??"*"))}static raise(e){throw e}static isFunction=e=>{const t=Object.prototype.toString.call(e).slice(8,-1).toLowerCase();return"function"===t||"asyncfunction"===t};static isSymbol=e=>"symbol"==typeof e;static toElement=e=>e instanceof HTMLElement?e:utils.raise(`node ${e} is not HTMLElement`);static toTemplate=e=>e instanceof HTMLTemplateElement?e:utils.raise(`node ${e} is not HTMLTemplateElement`);static toInput=e=>e instanceof HTMLInputElement?e:utils.raise(`node ${e} is not HTMLInputElement`);static toKebabCase=e=>e.replaceAll(/([A-Z])/g,((e,t,s)=>(s>0?"-":"")+t.toLowerCase()))};class n{component;prop;indexes;path;key;constructor(e,t,n){const o=n??[];this.component=e,this.prop=t,this.indexes=o,this.path=s.getPath(t,o),this.indexesKey=this.indexes.join("\t"),this.key=`${this.prop}\t${this.indexesKey}`}}class o{node;props;proc;constructor(e,t,s){this.node=e,this.props=t,this.proc=s}}class i{queue=[];enqueue(e,t=this.queue){t.push(e)}static reorder(e){const t=e.slice();return t.sort(((e,t)=>e.node instanceof HTMLSelectElement&&1===e.props.length&&"value"===e.props[0]?1:-1)),t}exec(e=this.queue){for(;;){const t=e.slice();if(0===t.length)break;e.splice(0);const s=i.reorder(t);for(const e of s)e.proc()}}}class a{asyncProc=new t;notify=new class{queue=[];component;constructor(e){this.component=e}enqueue(e,t=this.queue){e.component.isInitializing||t.push(e)}updateElements(e=this.queue){for(;;){const t=e.slice();if(0===t.length)break;e.splice(0);const s=new Map;t.forEach((e=>{s.has(e.component)||s.set(e.component,[]),s.get(e.component).push(e)}));for(let[e,t]of s.entries()){e?.updateActiveProperty();const s=e?.viewModelProxy,o=t=>{const o=s?.$setOfArrayProps??new Set,i=s?.$setOfRelativePropsByProp??new Set,a=new Set;for(const e of t){if(!o.has(e.prop))continue;const s=i[e.prop]??new Set;for(const e of t)s.has(e.prop)&&a.add(e)}t=t.filter((e=>!a.has(e)));const r=[];("$onNotify"in s??1)&&r.push(...Array.from(t).flatMap((e=>s.$onNotify(e))).filter((e=>null!=e)).flatMap((t=>{const s=t.prop.match(/\*/g)?.length??0;return t.indexes.length<s?(e.activeProperties.search(t.prop,t.indexes)??[]).map((t=>new n(e,t.name,t.indexes))):new n(e,t.prop,t.indexes)})));for(const s of t){let t=new Set;if(o.has(s.prop)){const e=`${s.prop}.*.`;i.get(s.prop)?.forEach((s=>!s.startsWith(e)&&t.add(s)))}else t=i.get(s.prop)??new Set;r.push(...Array.from(t).map((t=>new n(e,t,s?.indexes))))}return r},i=[t];let a=t;for(;;){const e=o(a);if(0===e.length)break;i.push(e),a=e}const r=i.flatMap((e=>e)),c=new Map;r.reduce(((e,t)=>e.set(t.path,t)),c);const p=new Set(c.keys());s.$deleteCache(p),e.binder.update(p,new Set),("$onChange"in s??1)&&s.$asyncProc((async()=>{await s.$onChange(Array.from(c.values()))}))}}}};updateNodeScheduler=new i;constructor(){}enqueueAsyncProc(e){this.asyncProc.enqueue(e)}enqueueNotify(e){this.notify.enqueue(e)}enqueueUpdateNode(e){this.updateNodeScheduler.enqueue(e)}async exec(){for(;await this.asyncProc.exec(),this.notify.updateElements(),this.updateNodeScheduler.exec(),0!=this.asyncProc.queue.length||0!=this.notify.queue.length||0!=this.updateNodeScheduler.queue.length;);}}class r{resolve;reject;updator;component;constructor(e=null){this.component=e,this.main()}wakeup(e){this.resolve(e)}stop(){this.reject()}sleep(){return new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}async main(){for(;;)try{this.updator=await this.sleep();try{await this.updator.exec()}finally{this.updator=null}}catch(e){if(void 0!==e&&(console.error(e),!confirm("致命的エラーが発生しました。継続しますか？")))break}}asyncProc(t,s,n){const o=this.updator??new a;o.enqueueAsyncProc(new e(t,s,n)),this.updator||this.wakeup(o)}notify(e,t,s){const o=this.updator??new a;o.enqueueNotify(new n(e,t,s)),this.updator||this.wakeup(o)}updateNode(e,t,s){const n=this.updator??new a;n.enqueueUpdateNode(new o(e,t,s)),this.updator||this.wakeup(n)}static queue=[new r];static get current(){return this.queue.at(-1)}static suspend(e){this.queue.push(new r(e))}static resume(){this.queue.pop().stop()}}const c=class{static cache=new Map;static trim=e=>e.trim();static has=e=>e.length>0;static parseFilter=e=>{const[t,...s]=e.split(",").map(this.trim);return Object.assign(new class{name;options},{name:t,options:s})};static parseViewModelProp=e=>{const[t,...s]=e.split("|").map(this.trim);return[t,s.map((e=>this.parseFilter(e)))]};static parseBind=(e,t)=>{const[s,n]=[t].concat(...e.split(":").map(this.trim)).splice(-2),[o,i]=this.parseViewModelProp(n);return[s,o,i]};static parseBinds=(e,t)=>{const s=`${e}\t${t}`;if(this.cache.has(s))return this.cache.get(s);{const n=e.split(";").map(this.trim).filter(this.has).map((e=>this.parseBind(e,"$"))).map((([e,s,n])=>(s="@"===s?e:s,[e="$"===e?t:e,s,n])));return this.cache.set(s,n),n}}};class p{name;paths=[];level;regexp;constructor(e){this.name=e,this.paths=e.split("."),this.last=this.paths.at(-1),this.level=e.match(/\*/g)?.length??0,this.regexp=this.level>0?new RegExp("^"+e.replaceAll("*","(\\w+)").replaceAll(".","\\.")+"$"):null,this.listParentPaths=[];for(let e=1;e<this.paths.length;e++)this.listParentPaths.push(this.paths.slice(0,-e));this.parentPathsByPath=new Map,this.setOfParentPath=new Set,this.setOfExpandPath=new Set,this.listParentPaths.forEach((e=>{const t=e.join(".");this.setOfParentPath.add(t),"*"===t.at(-1)&&this.setOfExpandPath.add(t.slice(0,-2)),this.parentPathsByPath.set(t,e)})),this.parentPaths=this.listParentPaths[0]??[],this.parentPath=this.parentPaths.join("."),this.isPrimitive=0===this.parentPaths.length,this.isParentPrimitive=1===this.parentPaths.length,this.privateName=this.isPrimitive?"__"+e:null}getNameByIndexes(e){return s.getPath(this.name,e)}static propByName=new Map;static create(e){if(this.propByName.has(e))return this.propByName.get(e);{const t=new p(e);return this.propByName.set(e,t),t}}}class l{definedProp;name;path;indexes;indexesString;indexesStrings;prentPath;constructor(e,t,n,o,i){this.definedProp=e,this.name=e.name,this.path=t,this.indexes=n,this.indexesString=o,this.key=i,this.indexesStrings=Array(n.length);for(let e=0;e<n.length;e++)this.indexesStrings[e]=n.slice(0,e+1).toString();this.parentPath=s.getPath(e.parentPath,n)}static propByPath=new Map;static create(e,t=[]){const n=t.toString(),o=e+"\t"+n;if(this.propByPath.has(o))return this.propByPath.get(o);{const i=s.getPath(e,t),a=p.create(e),r=new l(a,i,t,n,o);return this.propByPath.set(o,r),r}}static getValue(e,t){return e.$getValue(t.name,t.indexes,t.path)}static setValue(e,t,s){return e.$setValue(t.name,t.indexes,t.path,s),!0}}class h{point=0;last=0;name;results=0;constructor(e,t){this.name=e,this.point=0,this.last=performance.now(),this.results=t}check(){this.point++;const e=performance.now(),t=e-this.last;this.results.has(this.point)?this.results.set(this.point,this.results.get(this.point)+t):this.results.set(this.point,t),this.last=e}static resultsByName=new Map;static create(e){let t=this.resultsByName.get(e);return null==t&&(new Map,this.resultsByName.set(e,t)),new h(e,t)}}class d{static localeString=(e,t)=>null!=e?Number(e).toLocaleString():"";static fixed=(e,t)=>e?.toFixed(t[0]??0)??"";static styleDisplay=(e,t)=>e?t[0]??"":"none";static truthy=(e,t)=>!!e;static falsey=(e,t)=>!e;static not=this.falsey;static upperCase=(e,t)=>e?.toUpperCase()??"";static lowerCase=(e,t)=>e?.toLowerCase()??"";static eq=(e,t)=>e==t[0];static ne=(e,t)=>e!=t[0];static lt=(e,t)=>Number(e)<Number(t[0]);static le=(e,t)=>Number(e)<=Number(t[0]);static gt=(e,t)=>Number(e)>Number(t[0]);static ge=(e,t)=>Number(e)>=Number(t[0]);static embed=(e,t)=>decodeURI((t[0]??"").replaceAll("%s",e));static ifText=(e,t)=>e?t[0]??"":t[1]??"";static null=(e,t)=>null==e}class u{}class m{static applyForInput=(e,t)=>t.reduceRight(((e,t)=>t.name in u?u[t.name](e,t.options):e),e);static applyForOutput=(e,t)=>t.reduce(((e,t)=>t.name in d?d[t.name](e,t.options):e),e)}class f extends FileReader{constructor(){super()}#e(e,t){return new Promise(((s,n)=>{super.addEventListener("load",(({target:e})=>s(e.result))),super.addEventListener("error",(({target:e})=>n(e.error))),super[t](e)}))}readAsArrayBuffer(e){return this.#e(e,"readAsArrayBuffer")}readAsDataURL(e){return this.#e(e,"readAsDataURL")}readAsText(e){return this.#e(e,"readAsText")}}class y{static param1(e,t,s,n,o,i){l.setValue(n,o,m.applyForInput(e[t],i))}static param2(e,t,s,n,o,i){l.setValue(n,o,m.applyForInput(e[s[0]][s[1]],i))}static className(e,t,s,n,o,i){}static radio(e,t,n,o,i,a){const r=s.toElement(e);r.checked&&l.setValue(o,i,m.applyForInput(r.value,a))}static checkbox(e,t,n,o,i,a){const r=s.toElement(e),c=l.getValue(o,i),p=m.applyForInput(r.value,a);if(r.checked)c.push(p);else{const e=c.findIndex((e=>e==p));e>=0&&c.splice(e,1)}}static async file(e,t,n,o,i,a){const r=s.toInput(e);if(0==r.files.length)return;const c=new f,p=await c.readAsText(r.files[0]),h=m.applyForInput(p,a);l.setValue(o,i,h)}}class g{static param1(e,t,s,n,o,i){const a=l.getValue(e,t),c=m.applyForOutput(a,i);r.current.updateNode(s,[n],(()=>{s[n]=c}))}static param2(e,t,s,n,o,i){const a=m.applyForOutput(l.getValue(e,t),i);r.current.updateNode(s,o,(()=>{s[o[0]][o[1]]=a}))}static className(e,t,n,o,i,a){const c=s.toElement(n),p=m.applyForOutput(l.getValue(e,t),a);r.current.updateNode(n,["classList"],(()=>{p?c.classList.add(i[1]):c.classList.remove(i[1])}))}static radio(e,t,n,o,i,a){const c=s.toElement(n),p=m.applyForOutput(l.getValue(e,t),a);r.current.updateNode(n,["checked"],(()=>{c.checked=c.value==p}))}static checkbox(e,t,n,o,i,a){const c=s.toElement(n),p=m.applyForOutput(l.getValue(e,t),a);r.current.updateNode(n,["checked"],(()=>{c.checked=!!p.find((e=>e==c.value))}))}static file(e,t,s,n,o,i){}}const P={param1:[y.param1,g.param1],param2:[y.param2,g.param2],className:[y.className,g.className],radio:[y.className,g.className],checkbox:[y.className,g.className],file:[y.className,g.className]},w=new Set(["INPUT","SELECT","TEXTAREA","OPTION"]),v=new Set(["radio","checkbox"]);class x{nodes=[];value;boundNodes=[];root;key;removeNodes(){this.nodes.forEach((e=>e.parentNode&&e.parentNode.removeChild(e))),this.nodes.splice(0)}update(e,t){this.boundNodes.forEach((s=>s.update(e,t)))}init(){this.boundNodes.forEach((e=>e.init()))}}class b{node;get element(){return s.toElement(this.node)}get template(){return s.toTemplate(this.node)}get component(){return this.node instanceof X?this.node:s.raise(`node ${this.node} is not component`)}get input(){return s.toInput(this.node)}parentComponent;viewModelProxy;loopNode;viewModelIndex;defaultProperty;defaultEvent="click";viewModelPropByProp=new Map;propsByViewModelPath=new Map;pathsByProp=new Map;loopViewModelProp=null;loopChildren=[];loopValue;viewModelHandlerByEvent=new Map;constructor(e,t,n){this.parentComponent=e,this.node=t,this.loopNode=n,this.viewModelProxy=e?.viewModelProxy??null,this.defaultProperty=(e=>{if(e instanceof HTMLElement){const t=s.toElement(e);return w.has(t.tagName)?v.has(t.type)?"checked":"value":"textContent"}return"textContent"})(t)}#t(e,t,s,n,o,i){const a=new x,r=0===s.definedProp.level?[o]:s.indexes.concat(o);return a.root=document.importNode(n.content,!0),a.boundNodes=M.select(e,a.root,n,t,r),a.nodes=Array.from(a.root.childNodes),a.key=o,a.value=i,a}#s(){const e=this.template,t=this,s=this.viewModelProxy,n=this.loopViewModelProp,o=this.loopChildren,i=this.parentComponent;this.loopValue=l.getValue(s,n),o.push(...Object.entries(this.loopValue).map((([s,o])=>{const a=new x,r=0===n.definedProp.level?[s]:n.indexes.concat(s);return a.root=document.importNode(e.content,!0),a.boundNodes=M.select(i,a.root,e,t,r),a.nodes=Array.from(a.root.childNodes),a.key=s,a.value=o,a})));const a=document.createDocumentFragment();o.forEach((e=>a.appendChild(e.root))),e.after(a)}#n(){this.loopChildren.forEach((e=>e.removeNodes())),this.loopChildren=[],this.#s(),this.loopChildren.forEach((e=>e.init()))}#o(e,t){const s=e.parentElement,n=s.cloneNode();s.replaceWith(n);try{t()}finally{n.replaceWith(s)}}#i(e){const t=e.trim();this.loopViewModelProp=l.create(t,this.viewModelIndexes)}#a(e,t,s,n,o={}){const i=this.viewModelPropByProp,a=this.propsByViewModelPath,c=this.pathsByProp,p=l.create(t,s);i.set(e,{viewModelProp:p,filters:n});const h=a.get(p.path);h?h.push(e):a.set(p.path,[e]);let d=c.get(e);if(null==d){const t=e.split("."),[s,n]=2===t.length&&"class"===t[0]?P.className:"radio"===e||"checkbox"===e||"file"===e?P[e]:1===t.length||2===t.length?P["param"+t.length]:console.error(`unknown property name ${e}`);d={updateNodeFunc:n,updateViewModelFunc:s,paths:t},c.set(e,d)}if(this.node instanceof X){const t=this.component,s=this.viewModelProxy;"dialog"in t.dataset?Object.defineProperty(t.viewModel,e,{get:()=>Reflect.get(o,p.name),set:e=>Reflect.set(o,p.name,e)}):s?(t.viewModelProxy.$addImportProp(e),Object.defineProperty(t.viewModel,e,{get:()=>l.getValue(s,p),set:e=>l.setValue(s,p,e)})):Object.defineProperty(t.viewModel,e,{get:()=>Reflect.get(k,p.name),set:e=>Reflect.set(k,p.name,e)});const n=e;r.current.notify(t,n,[])}else{const t=this.viewModelProxy,s=this.node,o=e,i=d.updateNodeFunc,a=d.paths;Reflect.apply(i,this,[t,p,s,o,a,n])}}#r(e){const t=this.viewModelIndexes,s=this.viewModelHandlerByEvent;c.parseBinds(e??"",this.defaultProperty).forEach((([e,n,o])=>{"o"===e[0]&&"n"===e[1]?s.set(e,n):this.#a(e,n,t,o)}))}#c(e){const t=this.viewModelIndexes;c.parseBinds(e??"",this.defaultProperty).forEach((([e,s,n])=>{this.#a(e,s,t,n)}))}parse(e,t={}){this.viewModelIndexes=e;const s=this.node;if(s instanceof Comment){const e=s.textContent.slice(2);this.node=document.createTextNode(""),s.parentNode.replaceChild(this.node,s),this.#c(e)}else{const s=this.element;if(s instanceof HTMLTemplateElement)"bind"in s.dataset&&(this.#i(s.dataset.bind),this.#o(s,(()=>{this.#s()})));else if("dialog"in s.dataset)for(const s of Object.keys(t)){const n=s;this.#a(s,n,e,[],t)}else"bind"in s.dataset&&this.#r(s.dataset.bind)}}#p(e,t,n,o,i){if(!(n instanceof X)){const{paths:a,updateNodeFunc:r}=this.pathsByProp.get(o);return!r&&s.raise(`unknown property ${o}`),Reflect.apply(r,this,[e,t,n,o,a,i])}{const e=n;r.current.notify(e,o,[])}}#l(e,t,n,o,i){const{paths:a,updateViewModelFunc:r}=this.pathsByProp.get(t);return!r&&s.raise(`unknown property ${t}`),Reflect.apply(r,this,[e,t,a,n,o,i])}init(){const e=this.parentComponent,t=this.node,s=this.viewModelProxy,n=this.viewModelIndexes,o=this.defaultProperty,i=this.pathsByProp;if(t instanceof Text)return;const a=this.element;if(!this.viewModelHandlerByEvent.has("input")){const e=i.has("file")?"file":i.has("radio")?"radio":i.has("checkbox")?"checkbox":o;if("textContent"!==e){const{viewModelProp:n,filters:o}=this.viewModelPropByProp.get(e)??{};null!=n&&a.addEventListener("input",(i=>{i.stopPropagation(),r.current.asyncProc((()=>this.#l(t,e,s,n,o)),this,[])}))}}for(const[t,o]of this.viewModelHandlerByEvent.entries()){const i=t.slice(2);a.addEventListener(i,(t=>{t.stopPropagation(),r.current.asyncProc((()=>e.stackIndexes.push(n,(()=>Reflect.apply(s[o],s,[t,...n])))),this,[])}))}this.loopChildren.forEach((e=>e.init()))}update(e,t){if(null!=this.loopViewModelProp)if(e.has(this.loopViewModelProp.path)){const e=s.toElement(this.node);this.#o(e,(()=>{this.#n()}))}else this.loopChildren.forEach((s=>s.update(e,t)));else{const s=this.node,n=this.viewModelProxy;for(const[o,i]of this.propsByViewModelPath.entries())(e.has(o)||t.has(o))&&i.forEach((e=>{const{viewModelProp:t,filters:o}=this.viewModelPropByProp.get(e);this.#p(n,t,s,e,o)}))}}static create(e,t,s=null){return new b(e,t,s)}}const N=e=>{const t=[];for(;null!=e.parentNode;)t.unshift(Array.from(e.parentNode.childNodes).indexOf(e)),e=e.parentNode;return t};class M{static listOfRouteIndexesByTemplate=new Map;static select(e,t,s,n=null,o=[]){const i=[],a=t=>{const s=b.create(e,t,n);return s.parse(o),s};if(this.listOfRouteIndexesByTemplate.has(s)){const e=this.listOfRouteIndexesByTemplate.get(s).map((e=>e.reduce(((e,t)=>e.childNodes[t]),t)));i.push(...e.map((e=>a(e))))}else{const e=[],n=[],o=Array.from(t.querySelectorAll("[data-bind]"));n.push(...o.map((e=>N(e))));const r=[],c=e=>e.childNodes.forEach((e=>{e instanceof Comment&&"@"===e.textContent[0]&&"@"===e.textContent[1]&&r.push(e),c(e)}));c(t),n.push(...r.map((e=>N(e)))),this.listOfRouteIndexesByTemplate.set(s,n),e.push(...o),e.push(...r),i.push(...e.map((e=>a(e))))}return i}}const $=e=>e.init();class E{boundNodes=[];component;constructor(e){this.component=e}add(e){this.boundNodes.push(e)}bind(e){this.boundNodes.push(...M.select(this.component,e,this.component.template))}init(){this.boundNodes.forEach($)}update(e,t){this.boundNodes.forEach(((e,t)=>s=>s.update(e,t))(e,t))}async walk(e){const t=async s=>{for(const n of s){await e(n);for(const e of n.loopChildren)await t(e.boundNodes)}};await t(this.boundNodes)}async findNode(e,t){await this.walk((async s=>{const n=Array.from(s.propsByViewModelPath.keys());for(const o of n.filter((t=>e.has(t))))await t(o,s.node)}))}static rootBinder=new E(null)}const k=new Proxy({},new class{set(e,t,s,n){return Reflect.set(e,t,s,n),E.rootBinder.update(new Set([t]),new Set([`$$${t}`])),!0}}),C=e=>t=>()=>{const s=e.viewModelProxy;return Reflect.apply(t,s,[])},R=e=>t=>s=>{const n=e.viewModelProxy;return Reflect.apply(t,n,[s])},B=class{static build(e,t=e.viewModel){const n=new Map,o=new Set(Object.keys(t).filter((e=>e.startsWith("__")))),i=new Set(Object.keys(t).filter((e=>"$"===e[0]&&"$"!==e[1]))),a=new Set(Object.keys(t).filter((e=>e.startsWith("$$")))),r=[],c=(s,i=null)=>{if(a.has(s))n.set(s,(e=>({get:()=>(e=>()=>{const t=e.slice(2);return k?.[t]})(e)(),set:t=>(e=>t=>{const s=e.slice(2);return k[s]=t,!0})(e)(t),enumerable:!0,configurable:!0}))(s));else{const a=p.create(s);a.isPrimitive?(n.set(s,((e,t)=>({get:()=>((e,t)=>()=>{const s=e.viewModelProxy,n=e.viewModel;return Reflect.get(n,"__"+t,s)})(e,t)(),set:s=>((e,t)=>s=>{const n=e.viewModelProxy,o=e.viewModel;return Reflect.set(o,"__"+t,s,n),!0})(e,t)(s),enumerable:!0,configurable:!0}))(e,s)),o.has(a.privateName)||(Object.defineProperty(t,a.privateName,(e=>({value:e,writable:!0,enumerable:!0,configurable:!0}))(i)),o.add(a.privateName))):n.set(s,((e,t)=>{const{parentPath:s,last:n,level:o}=t;return{get:()=>((e,t,s,n)=>()=>{const o=e.viewModelProxy,i=e.viewModel,a="*"===s?e.stackIndexes.current[n-1]:s;let r;return r=0===n?o[t][a]:Reflect.get(i,t,o)?.[a],r})(e,s,n,o)(),set:t=>((e,t,s,n)=>o=>{const i=e.viewModelProxy,a=e.viewModel,r="*"===s?e.stackIndexes.current[n-1]:s;return 0===n?i[t][r]=o:Reflect.get(a,t,i)[r]=o,!0})(e,s,n,o)(t),enumerable:!0,configurable:!0}})(e,a))}};for(const[e,s]of Object.entries(t))o.has(e)||i.has(e)||(s!==Symbol.for("import")?c(e,s):r.push(e));for(const[o,i]of Object.entries(Object.getOwnPropertyDescriptors(Object.getPrototypeOf(t)))){if("constructor"===o)continue;if(s.isFunction(i.value))continue;n.has(o)||c(o);const t=n.get(o);i.get&&(t.get=()=>C(e)(i.get)()),i.set&&(t.set=t=>R(e)(i.set)(t))}Object.keys(t).filter((e=>!o.has(e)&&!i.has(e))).forEach((e=>delete t[e])),Array.from(n.entries()).forEach((([e,s])=>Object.defineProperty(t,e,s)));const l=Object.keys(t).concat(r),h=l.map((e=>p.create(e))),d=l.filter((e=>`${e}.*`in t)),u=new Map;return h.reduce(((e,t)=>(e.set(t.name,new Set(h.filter((e=>e.setOfParentPath.has(t.name))).map((e=>e.name)))),e)),u),{importProps:r,arrayProps:d,setOfRelativePropsByProp:u,definedProperties:h}}},I=Symbol.for("raw"),O=Symbol.for("isProxy"),A=new Set(["$getValue","$setValue","$init","$deleteCache","$asyncProc","$notify","$openDialog","$closeDialog","$cancelDialog","$addImportProp","$findNode"]),S=new Map;S.set("$indexes",(e=>e.component.stackIndexes.current)),S.set("$component",(e=>e.component)),S.set("$setOfImportProps",(e=>e.setOfImportProps)),S.set("$setOfArrayProps",(e=>e.setOfArrayProps)),S.set("$setOfRelativePropsByProp",(e=>e.setOfRelativePropsByProp));const V=new Set(["$1","$2","$3","$4","$5","$6","$7","$8","$indexes","$component","$setOfImportProps","$setOfArrayProps","$setOfRelativePropsByProp"]);class D extends Map{#h=!1;#d;constructor(e){super(),this.#d=e}set(e,t){this.#d.activeProperties?.has(e)&&(t=t?.[O]?t[I]:t,super.set(e,t),this.#h&&!s.isSymbol(e)&&console.log(`cache.set(${e}, ${t}) = ${result}, ${this.#d?.tagName}`))}deleteRelative(e){const t=this.#d.activeProperties;this.has(e)&&this.delete(e),t?.has(e)&&t.walkByParentPath(e,(e=>this.delete(e.path)))}}class F{component;prop;indexes;constructor(e,t){this.component=e,this.prop=t,this.indexes=e.stackIndexes.current?.slice(0)}get(e,t,s){return t===O||(t===I?e:Reflect.get(e,t,s))}set(e,t,s,n){return Reflect.set(e,t,s,n),"length"===t&&r.current.notify(this.component,this.prop,this.indexes??[]),!0}}const T=(e,t,s)=>(s=s?.[O]?s[I]:s)instanceof Array?new Proxy(s,new F(e,t)):s;class L{component;cache;importProps=[];setOfImportProps=new Set;arrayProps;setOfArrayProps;setOfRelativePropsByProp;constructor(e,t,s,n){this.component=e,this.#u(...t),this.cache=new D(e),this.arrayProps=s,this.setOfArrayProps=new Set(s),this.setOfRelativePropsByProp=n}#u(...e){this.importProps.push(...e),e.forEach((e=>this.setOfImportProps.add(e)))}$addImportProp(...e){e.pop(),e.pop(),Reflect.apply(this.#u,this,e)}$getValue(e,t,n,o,i){n=n??s.getPath(e,t);const a=this.cache,r=this.component;let c;return c=a.has(n)?T(r,e,a.get(n)):r.stackIndexes.push(t,(function(){const t=Reflect.get(o,e,i);return a.set(n,t),T(r,e,t)})),c}$setValue(e,t,n,o,i,a){n=n??s.getPath(e,t);const r=this.cache,c=(this.component,this.$notify),p=this;this.component.stackIndexes.push(t,(function(){return Reflect.set(i,e,o,a),r.deleteRelative(n),Reflect.apply(c,p,[e,t??[]]),!0}))}$asyncProc(...e){const t=e.pop();e.pop(),r.current.asyncProc(e[0],t,e[1]??[])}$notify(e,t){e.startsWith("__")||e.startsWith("$")||this.setOfImportProps.has(e)||r.current.notify(this.component,e,t??[])}async $init(e,t){"$relativeProps"in e&&Reflect.get(e,"$relativeProps",t).forEach((([e,t])=>{t.forEach((t=>{const s=this.setOfRelativePropsByProp.get(t).add(e)??new Set([e]);this.setOfRelativePropsByProp.set(t,s)}))})),"$onInit"in e&&await Reflect.apply(e.$onInit,t,[])}$deleteCache(e){const t=this.cache;for(const s of Array.from(e))t.deleteRelative(s)}async $openDialog(...e){e.pop(),e.pop();const[t,s={}]=e,n=this.component;r.suspend(n);const o=Z.tagName(t),i=document.createElement("template");i.innerHTML=`<${o} data-dialog></${o}>`;const a=document.importNode(i.content,!0),c=a.querySelector(o);try{return await new Promise((async(e,t)=>{c.setDialogInfo(n,e,t,s),document.body.appendChild(a),await c.initializePromise}))}catch(e){}finally{document.body.removeChild(c),r.resume()}}$closeDialog(e){this.component.closeDialog(e)}$cancelDialog(){this.component.cancelDialog()}$findNode(e,t){this.component.binder.findNode(e,t)}setOfNames;get(e,t,n){if(t in e){if(t.includes("*")){const s=Reflect.get(e,t,n);return T(this.component,t,s)}{if(this.cache.has(t))return T(this.component,t,this.cache.get(t));const s=Reflect.get(e,t,n);return this.cache.set(t,s),T(this.component,t,s)}}if(this.component.activeProperties?.has(t)){const s=this.component.activeProperties.get(t);return this.$getValue(s.name,s.indexes,s.path,e,n)}if("$"===t[0]){if(A.has(t))return(...s)=>Reflect.apply(this[t],this,[...s,e,n]);if(V.has(t)){const e=S.get(t);return e?e(this):s.isSymbol(t)?Reflect.get(this,t):this.component.stackIndexes.current[parseInt(t.slice(1))-1]}}}set(e,t,s,n){if(!(t in e)&&this.component.activeProperties.has(t)){const o=this.component.activeProperties.get(t);return this.$setValue(o.name,o.indexes,o.path,s,e,n),!0}Reflect.set(e,t,s,n),this.cache.deleteRelative(t);const o=this.component.stackIndexes.current;return this.$notify(t,o),!0}has(e,t,s){if("$"===t[0]){if(A.has(t))return!0;if(V.has(t))return!0}return t in e||Reflect.has(e,t,s)}}const j=Proxy,q=class{static create(e,t=e.viewModel){const{importProps:s,arrayProps:n,setOfRelativePropsByProp:o}=B.build(e);return new j(t,new L(e,s,n,o))}};class H{component;constructor(e){this.component=e}render(e=this.component,t=e.binder,s=e.template,n=e.shadowRoot??e){const o=document.importNode(s.content,!0);t.bind(o),t.init(),n.appendChild(o)}}class z extends H{get css(){return"\n.bg {\n  position: fixed;\n  display: flex;\n  align-items: center;\n  justify-content: space-around;\n  background-color: rgba(0, 0, 0, 0.5);\n  left: 0;\n  top: 0;\n  height: 100vh;\n  width: 100vw;\n  z-index: fixed;\n  position: fixed;\n  position: 499;\n}\n.fg {\n  background-color: white;\n  border-radius: .375rem;\n  padding: 3rem;\n}\n    "}render(e=this.component,t=e.binder,s=e.template,n=e.shadowRoot??e){const o=document.importNode(s.content,!0);t.bind(o),t.init();const i=document.createElement("style");i.innerHTML=this.css,n.appendChild(i);const a=document.createElement("div");a.classList.add("bg");const r=document.createElement("div");r.classList.add("fg"),a.appendChild(r),r.appendChild(o),n.appendChild(a),a.addEventListener("click",(()=>e.cancelDialog())),r.addEventListener("click",(e=>e.stopPropagation()))}}class _{stack=[];push(e,t){let s;this.stack.push(e);try{s=t()}finally{this.stack.pop()}return s}get current(){return this.stack[this.stack.length-1]}}class U extends Map{activePropertiesByName=new Map;activePropertiesByParentPath=new Map;search(e,t){const s=this.activePropertiesByName.get(e)??[],n=t.toString();return s.filter((e=>0===t.length||e.indexesStrings[t.length-1]===n))}walkByParentPath(e,t){const s=this.activePropertiesByParentPath,n=e=>{(s.get(e)??[]).forEach((e=>{t(e),n(e.path)}))};n(e)}build(){const e=this.activePropertiesByName;this.forEach((t=>e.has(t.name)?e.get(t.name).push(t):e.set(t.name,[t])));const t=this.activePropertiesByParentPath;this.forEach((e=>t.has(e.parentPath)?t.get(e.parentPath).push(e):t.set(e.parentPath,[e])))}static create(e){const t=Object.keys(e).filter((e=>!(e=>"_"===e[0]&&"_"===e[1]||"$"===e[0])(e))).map((e=>p.create(e))),s=t.reduce(((e,t)=>null===e||e<t.level?t.level:e),null),n=new Map,o=(t,s,o)=>{if(n.has(o))return n.get(o);const i=e.$getValue(t,s,o),a=Object.keys(i);return n.set(o,a),a},i=[],a=new Map,r=t.reduce(((e,t)=>e.has(t.level)?(e.get(t.level).push(t),e):e.set(t.level,[t])),new Map);for(let e=0;e<=s;e++){const t=r.get(e)??[];if(0!==e)t.filter((e=>"*"===e.last)).forEach((e=>{const s=[e].concat(t.filter((t=>t.setOfExpandPath.has(e.parentPath)))),n=a.get(e.parentPath);s.forEach((e=>{const t=[];n.forEach((s=>{const n=o(s.name,s.indexes,s.path);t.push(...n.map((t=>l.create(e.name,s.indexes.concat(t)))))})),a.set(e.name,t),i.push(...t)}))}));else{const e=t.map((e=>{const t=l.create(e.name);return a.set(t.name,[t]),t}));i.push(...e)}}const c=new U(i.map((e=>[e.path,e])));return c.build(),c}}class W extends HTMLElement{#m;#f;#y;#g;#P;#w;#v;#x;#b;template;viewModel;viewModelProxy;view;binder;stackIndexes;constructor(){super(),this.#P=!0,this.#f=new Promise(((e,t)=>{this.#y=e,this.#g=t}))}createView(){return"dialog"in this.dataset?new z(this):new H(this)}build(e){this.withoutShadowRoot||this.attachShadow({mode:"open"}),this.template=e.template,this.viewModel=Reflect.construct(e.ViewModel,[]),this.viewModelProxy=q.create(this),this.view=this.createView(),this.binder=new E(this),this.stackIndexes=new _}get parentComponent(){if(void 0===this.#m){let e=this;for(;e=e.parentNode,null!=e;){if(e instanceof ShadowRoot){e=e.host;break}if(e instanceof W)break}this.#m=e}return this.#m}set parentComponent(e){this.#m=e}get withoutShadowRoot(){return this.hasAttribute("without-shadowroot")}set withoutShadowRoot(e){e?this.setAttribute("without-shadowroot",""):this.removeAttribute("without-shadowroot")}get initializePromise(){return this.#f}get isInitializing(){return this.#P}setDialogInfo(e,t,s,n){this.#x=e,this.#w=t,this.#v=s,this.#b=n}get resolveForDialog(){return this.#w}get rejectForDialog(){return this.#v}get paramsForDialog(){return this.#b}get componentForDialog(){return this.#x}closeDialog(e){this.resolveForDialog(e)}cancelDialog(){this.rejectForDialog()}async dialogComponentInit(){r.current.asyncProc((async()=>{const e=b.create(this.componentForDialog,this);e.parse([],this.paramsForDialog),await this.viewModelProxy.$init(),this.updateActiveProperty(),e.init(),this.view.render()}),this,[])}async topComponentInit(){r.current.asyncProc((async()=>{const e=b.create(null,this);e.parse([]),await this.viewModelProxy.$init(),this.updateActiveProperty(),e.init(),E.rootBinder.add(e),this.view.render()}),this,[])}async defaultComponentInit(){r.current.asyncProc((async()=>{await this.parentComponent.initializePromise,await this.viewModelProxy.$init(),this.updateActiveProperty(),this.view.render()}),this,[])}async componentInit(){try{"dialog"in this.dataset?await this.dialogComponentInit():null==this.parentComponent?await this.topComponentInit():await this.defaultComponentInit()}finally{this.#P=!1,this.#y(!0)}}activeProperties;updateActiveProperty(){this.activeProperties=U.create(this.viewModelProxy)}async connectedCallback(){await this.componentInit()}disconnectedCallback(){}adoptedCallback(){}attributeChangedCallback(e,t,s){}}class K extends Map{set(e,t){super.set(e.toUpperCase(),t),customElements.define(e,class extends X{})}}class X extends W{constructor(){super(),super.build(Z.getComponentDataByTagName(this.tagName))}}class Z{static#N;static get prefix(){return this.#N}static set prefix(e){this.#N=e}static tagName(e){return this.#N?`${this.#N}-${e}`:e}static#M=new K;static getComponentDataByTagName(e){return this.#M.get(e)}static registComponentData(e,t){this.#M.set(s.toKebabCase(e),t)}}class G{html;css;template;ViewModel;static create(e){const t=Object.assign(new G,e);return t.template=t.template??this.createTemplate(this.mergeHtml(t.html,t.css)),t}static mergeHtml(e,t){return(t?`<style>${t}</style>`:"")+((e=e.replaceAll(/\{([^\}]+)\}/g,((e,t)=>`\x3c!--@@${t}--\x3e`)))??"")}static createTemplate(e){const t=document.createElement("template");return t.innerHTML=e,t}}window.redatax=class{static prefix=e=>(Z.prefix=e,this);static components=e=>{for(const[t,s]of Object.entries(e)){const e=G.create(s);Z.registComponentData(Z.tagName(t),e)}return this};static globals=e=>(Object.assign(k,e),this)}})();